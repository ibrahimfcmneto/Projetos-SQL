--Ibrahim Fleury de Camargo Madeira Neto / 25014766
--Thiago Viel Denadai / 25004361
--Vinícius Logatto Costa Sete / 25003510


CREATE TABLE categoria (
  id_categoria    NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nome            VARCHAR2(80) NOT NULL
);

CREATE TABLE fornecedor (
  id_fornecedor   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nome            VARCHAR2(120) NOT NULL,
  telefone        VARCHAR2(20)  -- pode ser NULL
);

CREATE TABLE produto (
  id_produto        NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nome              VARCHAR2(120) NOT NULL,
  sku               VARCHAR2(20)  NOT NULL UNIQUE,
  preco             NUMBER(10,2)  NOT NULL CHECK (preco >= 0),
  desconto_percent  NUMBER(5,2),              -- pode ser NULL
  estoque           NUMBER(10)    DEFAULT 0   NOT NULL,
  data_cadastro     DATE          DEFAULT SYSDATE NOT NULL,
  descontinuado_em  DATE,                      -- pode ser NULL
  id_categoria      NUMBER NOT NULL,
  id_fornecedor     NUMBER NOT NULL,
  CONSTRAINT fk_prod_cat FOREIGN KEY (id_categoria)  REFERENCES categoria(id_categoria),
  CONSTRAINT fk_prod_forn FOREIGN KEY (id_fornecedor) REFERENCES fornecedor(id_fornecedor)
);

CREATE TABLE cliente (
  id_cliente     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nome           VARCHAR2(120) NOT NULL,
  cpf            VARCHAR2(11)  NOT NULL,    -- guardado sem formatação
  telefone       VARCHAR2(20),               -- pode ser NULL
  email          VARCHAR2(120)
);

CREATE TABLE pedido (
  id_pedido     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  id_cliente    NUMBER       NOT NULL,
  data_pedido   DATE         DEFAULT SYSDATE NOT NULL,
  status        VARCHAR2(20) DEFAULT 'ABERTO' NOT NULL,
  observacoes   VARCHAR2(200),               -- pode ser NULL
  CONSTRAINT fk_ped_cli FOREIGN KEY (id_cliente) REFERENCES cliente(id_cliente)
);

CREATE TABLE item_pedido (
  id_pedido     NUMBER NOT NULL,
  id_produto    NUMBER NOT NULL,
  qtd           NUMBER(10,2) NOT NULL CHECK (qtd > 0),
  preco_unit    NUMBER(10,2) NOT NULL CHECK (preco_unit >= 0),
  desconto_item NUMBER(5,2),                 -- pode ser NULL
  CONSTRAINT pk_item_pedido PRIMARY KEY (id_pedido, id_produto),
  CONSTRAINT fk_item_ped  FOREIGN KEY (id_pedido)  REFERENCES pedido(id_pedido),
  CONSTRAINT fk_item_prod FOREIGN KEY (id_produto) REFERENCES produto(id_produto)
);

-- Dados de exemplo

INSERT INTO categoria (nome) VALUES ('Informática');
INSERT INTO categoria (nome) VALUES ('Escritório');
INSERT INTO categoria (nome) VALUES ('Acessórios');

INSERT INTO fornecedor (nome, telefone) VALUES ('Tech Distribuidora', '193333-0001');
INSERT INTO fornecedor (nome, telefone) VALUES ('Global Office',    NULL);        -- telefone NULL
INSERT INTO fornecedor (nome, telefone) VALUES ('MaxParts',         '112222-9999');

INSERT INTO produto (nome, sku, preco, desconto_percent, estoque, id_categoria, id_fornecedor, descontinuado_em)
VALUES ('Notebook Pro 14', 'NBP14-001', 6500.00, NULL,  15, 1, 1, NULL);

INSERT INTO produto (nome, sku, preco, desconto_percent, estoque, id_categoria, id_fornecedor)
VALUES ('Mouse Óptico', 'MOU-100', 60.00, 5, 120, 3, 3);

INSERT INTO produto (nome, sku, preco, desconto_percent, estoque, id_categoria, id_fornecedor)
VALUES ('Teclado Mecânico', 'TEK-200', 350.00, NULL, 40, 3, 3);

INSERT INTO produto (nome, sku, preco, desconto_percent, estoque, id_categoria, id_fornecedor, descontinuado_em)
VALUES ('Impressora Laser', 'IMP-500', 1200.00, 10, 5, 2, 2, TO_DATE('2025-12-31','YYYY-MM-DD'));

INSERT INTO produto (nome, sku, preco, desconto_percent, estoque, id_categoria, id_fornecedor)
VALUES ('Monitor 24"', 'MON-24FHD', 899.90, NULL, 22, 1, 1);

INSERT INTO cliente (nome, cpf, telefone, email) VALUES ('Ana Silva',    '12345678901', '1998888-7777', 'ana@ex.com');
INSERT INTO cliente (nome, cpf, telefone, email) VALUES ('Bruno Costa',  '98765432100', NULL,            'bruno@ex.com');  -- telefone NULL
INSERT INTO cliente (nome, cpf, telefone, email) VALUES ('Carla Mendes', '45678912300', '1199999-0000', 'carla@ex.com');

INSERT INTO pedido (id_cliente, data_pedido, status, observacoes)
VALUES (1, TRUNC(SYSDATE)-10, 'FECHADO', 'Compra online');

INSERT INTO pedido (id_cliente, data_pedido, status)
VALUES (2, TRUNC(SYSDATE)-2, 'ABERTO');

INSERT INTO item_pedido (id_pedido, id_produto, qtd, preco_unit, desconto_item)
VALUES (1, 1, 1, 6500.00, NULL);

INSERT INTO item_pedido (id_pedido, id_produto, qtd, preco_unit, desconto_item)
VALUES (1, 2, 2, 60.00,  0);

INSERT INTO item_pedido (id_pedido, id_produto, qtd, preco_unit, desconto_item)
VALUES (2, 5, 1, 899.90, NULL);

COMMIT;

/*
1) Crie uma função chamada aumentar_preco_porcentagem que receba um valor e uma porcentagem 
   e retorne o novo valor com o aumento aplicado. Em seguida, utilize a função em uma 
   consulta que exiba o nome do produto, o preço original e o resultado da função 
   aplicando um acréscimo de 10% sobre o preço.
*/
CREATE OR REPLACE FUNCTION aumentar_preco_porcentagem (
    p_valor        IN NUMBER,
    p_porcentagem  IN NUMBER
) 
RETURN NUMBER
IS
BEGIN
    -- Validação básica: se qualquer entrada for nula, retorna nulo
    IF p_valor IS NULL OR p_porcentagem IS NULL THEN
        RETURN NULL;
    END IF;
    
    -- A fórmula: NovoValor = Valor * (1 + (Porcentagem / 100))
    RETURN (p_valor * (1 + (p_porcentagem / 100)));
END;
/

SELECT
    nome,
    preco AS preco_original,
    aumentar_preco_porcentagem(preco, 10) AS preco_com_aumento_10
FROM
    produto;


/*
2) Implemente uma função de tabela chamada produtos_por_id_categoria que receba o 
   identificador de uma categoria e retorne todos os produtos pertencentes a essa categoria. 
   Para isso, crie um tipo de objeto representando uma linha da tabela produto e um tipo 
   de tabela baseado nesse objeto. Dentro da função, utilize PIPE ROW para retornar 
   cada produto. Por fim, realize um SELECT chamando a função e exibindo os produtos 
   da categoria informada.
*/

CREATE OR REPLACE TYPE obj_produto AS OBJECT (
    id_produto         NUMBER,
    nome               VARCHAR2(120),
    sku                VARCHAR2(20),
    preco              NUMBER(10,2),
    desconto_percent   NUMBER(5,2),
    estoque            NUMBER(10),
    data_cadastro      DATE,
    descontinuado_em   DATE,
    id_categoria       NUMBER,
    id_fornecedor      NUMBER
);
/

CREATE OR REPLACE TYPE tbl_produto AS TABLE OF obj_produto;
/

CREATE OR REPLACE FUNCTION produtos_por_id_categoria (
    p_id_categoria IN NUMBER
)
RETURN tbl_produto PIPELINED
IS
BEGIN
    IF p_id_categoria IS NULL THEN
        RETURN;
    END IF;

    FOR p IN (
        SELECT * FROM produto 
        WHERE id_categoria = p_id_categoria
    )
    LOOP
        PIPE ROW (
            obj_produto(
                p.id_produto,
                p.nome,
                p.sku,
                p.preco,
                p.desconto_percent,
                p.estoque,
                p.data_cadastro,
                p.descontinuado_em,
                p.id_categoria,
                p.id_fornecedor
            )
        );
    END LOOP;
    
    RETURN;
END;
/

SELECT * FROM TABLE(produtos_por_id_categoria(1));

SELECT * FROM TABLE(produtos_por_id_categoria(3));

/*
3) Atualize a função criada no exercício anterior para que ela receba o nome da 
   categoria em vez do identificador. A nova função, chamada produtos_por_nome_categoria, 
   deve retornar os produtos associados ao nome da categoria informado, desconsiderando 
   diferenças de maiúsculas e minúsculas. Após criar a função, realize um SELECT 
   chamando-a e exibindo os produtos da categoria “Informática”.
*/
CREATE OR REPLACE FUNCTION produtos_por_nome_categoria (
    p_nome_categoria IN VARCHAR2
)
RETURN tbl_produto PIPELINED
IS
BEGIN
    IF p_nome_categoria IS NULL THEN
        RETURN;
    END IF;

    FOR p IN (
        SELECT 
            prod.id_produto, 
            prod.nome, 
            prod.sku, 
            prod.preco, 
            prod.desconto_percent, 
            prod.estoque, 
            prod.data_cadastro, 
            prod.descontinuado_em, 
            prod.id_categoria, 
            prod.id_fornecedor
        FROM 
            produto prod
        JOIN 
            categoria cat ON prod.id_categoria = cat.id_categoria
        WHERE 
            UPPER(cat.nome) = UPPER(p_nome_categoria)
    )
    LOOP
        PIPE ROW (
            obj_produto(
                p.id_produto,
                p.nome,
                p.sku,
                p.preco,
                p.desconto_percent,
                p.estoque,
                p.data_cadastro,
                p.descontinuado_em,
                p.id_categoria,
                p.id_fornecedor
            )
        );
    END LOOP;
    
    RETURN;
END;
/

-- Consulta de teste:
SELECT * FROM TABLE(produtos_por_nome_categoria('Informática'));

/*
4) Crie uma consulta que exiba o identificador, o nome e o preço dos produtos, 
   mostrando também o preço com um acréscimo de 12%. A consulta deve classificar 
   cada produto em uma faixa de valor, utilizando CASE: produtos com preço final 
   maior ou igual a 2000 devem ser classificados como “ALTO”, entre 200 e 1999 
   como “MÉDIO” e abaixo de 200 como “BAIXO”. Ordene o resultado do mais caro 
   para o mais barato.
*/

WITH calculo AS (
    SELECT
        id_produto,
        nome,
        preco,
        (preco * 1.12) AS preco_final_12 -- O novo preço com 12%
    FROM
        produto
)

SELECT
    id_produto,
    nome,
    preco AS preco_original,
    preco_final_12,
    CASE
        WHEN preco_final_12 >= 2000 THEN 'ALTO'
        WHEN preco_final_12 >= 200  THEN 'MÉDIO' 
        ELSE 'BAIXO'
    END AS faixa_de_valor
FROM
    calculo
ORDER BY
    preco_final_12 DESC; -- Do mais caro para o mais barato

/*
5) Monte uma consulta que exiba o nome dos clientes e o CPF formatado no padrão 999.999.999-99. 
   Considere que o campo cpf na tabela está armazenado apenas com números e utilize 
   funções de manipulação de strings para inserir os pontos e o hífen nas posições corretas.
*/

SELECT
    nome,
    cpf,
    SUBSTR(cpf, 1, 3) || '.' ||
    SUBSTR(cpf, 4, 3) || '.' ||
    SUBSTR(cpf, 7, 3) || '-' ||
    SUBSTR(cpf, 10, 2) AS cpf_formatado
FROM
    cliente;

/*
6) Crie uma consulta que exiba o nome dos produtos e um código curto gerado a partir 
   das três primeiras letras do nome do produto (em letras maiúsculas), seguidas 
   de um hífen e das três primeiras letras do SKU. O resultado deve ser apresentado 
   em uma coluna chamada codigo_curto.
*/

SELECT
    nome,
    UPPER(SUBSTR(nome, 1, 3)) || '-' || SUBSTR(sku, 1, 3) AS codigo_curto
FROM
    produto;

/*
7) Elabore uma consulta que apresente informações de data para os pedidos realizados 
   no mês atual. A consulta deve mostrar o identificador do pedido, a data truncada 
   para o dia, o último dia do mês correspondente, a próxima sexta-feira a partir 
   da data do pedido e os valores de ano e mês extraídos da data. Os resultados 
   devem ser ordenados pela data do pedido.
*/

SELECT
    id_pedido,
    TRUNC(data_pedido) AS dia_do_pedido,
    LAST_DAY(data_pedido) AS ultimo_dia_do_mes,
    NEXT_DAY(data_pedido, 'SEXTA-FEIRA') AS proxima_sexta,
    EXTRACT(YEAR FROM data_pedido) AS ano,
    EXTRACT(MONTH FROM data_pedido) AS mes
FROM
    pedido
WHERE
    -- A data do pedido é maior ou igual ao 1º dia do mês atual
    data_pedido >= TRUNC(SYSDATE, 'MM')
    -- E (para ser 100% robusto) menor que o 1º dia do mês seguinte
    AND data_pedido < ADD_MONTHS(TRUNC(SYSDATE, 'MM'), 1)
ORDER BY
    data_pedido;

/*
8) Desenvolva uma consulta que exiba o nome, o preço e o percentual de desconto dos 
   produtos, calculando também o preço líquido após aplicar o desconto. Para 
   fornecedores com telefone cadastrado, exiba o texto “COM TELEFONE”; caso 
   contrário, mostre “SEM TELEFONE”. Utilize as funções NVL e NVL2 para tratar 
   valores nulos e apresentar os resultados corretamente.
*/

SELECT
    p.nome,
    p.preco,
    p.desconto_percent,
    
    p.preco * (1 - (NVL(p.desconto_percent, 0) / 100)) AS preco_liquido,
    
    NVL2(f.telefone, 'COM TELEFONE', 'SEM TELEFONE') AS status_telefone_fornecedor
FROM
    produto p
JOIN
    fornecedor f ON p.id_fornecedor = f.id_fornecedor;

/*
9) Crie uma Stored Procedure chamada deletar_produto que receba como parâmetro o 
   identificador de um produto e exclua esse registro da tabela produto. Após o 
   comando DELETE, utilize o atributo SQL%ROWCOUNT para verificar se alguma linha 
   foi realmente afetada. Caso o valor de SQL%ROWCOUNT seja igual a zero, exiba 
   no console a mensagem “Produto não encontrado (ID=…)”. Caso contrário, exiba 
   “Produto removido com sucesso!”. Todas as mensagens devem ser apresentadas 
   utilizando o comando DBMS_OUTPUT.PUT_LINE.
*/

CREATE OR REPLACE PROCEDURE deletar_produto (
    p_id_produto IN produto.id_produto%TYPE
)
IS
BEGIN
    DELETE FROM produto
    WHERE id_produto = p_id_produto;

    IF SQL%ROWCOUNT = 0 THEN
        DBMS_OUTPUT.PUT_LINE('Produto não encontrado (ID=' || p_id_produto || ')');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Produto removido com sucesso!');
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Erro ao deletar produto (ID=' || p_id_produto || '): ' || SQLERRM);
END;
/

SET SERVEROUTPUT ON;

BEGIN
    deletar_produto(p_id_produto => 9999);
END;
/

BEGIN
    deletar_produto(p_id_produto => 3);
END;
/

BEGIN
    deletar_produto(p_id_produto => 1);
END;
/

/*
10) Crie uma Stored Procedure chamada calcular_total_pedido que receba como parâmetro 
    de entrada o identificador de um pedido e devolva, em um parâmetro de saída, 
    o valor total do pedido em reais, calculado pela soma de qtd * preco_unit 
    dos itens associados. Caso o pedido não exista, a procedure deve informar no 
    console que o ID é inválido e retornar NULL no parâmetro de saída. Ao final, 
    exiba com DBMS_OUTPUT.PUT_LINE o total calculado formatado com duas casas decimais.
*/

CREATE OR REPLACE PROCEDURE calcular_total_pedido (
    p_id_pedido   IN  pedido.id_pedido%TYPE,
    p_valor_total OUT NUMBER
)
IS
    v_count_pedido NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO v_count_pedido
    FROM pedido
    WHERE id_pedido = p_id_pedido;

    IF v_count_pedido = 0 THEN
        DBMS_OUTPUT.PUT_LINE('ID de pedido inválido: ' || p_id_pedido);
        p_valor_total := NULL;
        RETURN;
    END IF;

    SELECT NVL(SUM(qtd * preco_unit), 0)
    INTO p_valor_total
    FROM item_pedido
    WHERE id_pedido = p_id_pedido;

    DBMS_OUTPUT.PUT_LINE(
        'Total do Pedido ' || p_id_pedido || ': R$ ' ||
        TO_CHAR(p_valor_total, 'FM9999999.00')
    );

EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Erro ao calcular total para o pedido ' || p_id_pedido || ': ' || SQLERRM);
        p_valor_total := NULL;
END;
/

SET SERVEROUTPUT ON;

DECLARE
    v_total_calculado NUMBER;
BEGIN
    calcular_total_pedido(
        p_id_pedido   => 1,
        p_valor_total => v_total_calculado
    );
    DBMS_OUTPUT.PUT_LINE('--> Valor retornado na variável: ' || v_total_calculado);
    
    calcular_total_pedido(
        p_id_pedido   => 2,
        p_valor_total => v_total_calculado
    );
    DBMS_OUTPUT.PUT_LINE('--> Valor retornado na variável: ' || v_total_calculado);
    
    calcular_total_pedido(
        p_id_pedido   => 999,
        p_valor_total => v_total_calculado
    );
    DBMS_OUTPUT.PUT_LINE('--> Valor retornado na variável: ' || v_total_calculado);

END;
/